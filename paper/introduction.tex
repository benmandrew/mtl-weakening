\section{Introduction}

Temporal properties of systems are often specified using logics such as Metric Temporal Logic~\cite{koymans1990} (\MTL{}), and these properties can be verified to hold using model-checking~\cite{cavada2014}. However, in the real world, system failures or degradation can invalidate these proofs by breaking their assumptions, in which case the desired properties may no longer hold. Yet, under degradation the system may still have some useful capabilities for reduced operation, and so \emph{logically weaker} versions of these properties may hold.

Given a degraded system $\mathcal{M}$, and an ideal \MTL{} property $\phi$ that doesn't hold in $\mathcal{M}$, we aim to derive $\phi'$, the strongest possible \emph{weakening} of $\phi$, such that $\phi\Rightarrow\phi'$. To constrain the search space, we focus on modifying the intervals of \MTL{} formulae. For example, we may want an elevator to always arrive at least 30 seconds after calling it, represented by
\begin{equation}
\Box(\texttt{callElevator}\rightarrow\eventually{[0,30]}\texttt{elevatorArrives})
\end{equation}
(where $\Box$ is the \textit{always} operator and $\Diamond_{[0,30]}$ is the \textit{eventually} operator bounded between zero and thirty time units). However, if the main motor breaks, a weaker backup motor may start, slowing the system down. In this case the ideal property may not hold, and we may only be able to guarantee that the elevator will arrive within 60 seconds, represented by
\begin{equation}
\Box(\texttt{callElevator}\rightarrow\eventually{[0,60]}\texttt{elevatorArrives}).
\end{equation}
This property is logically weaker than the original, but still guarantees a useful level of functionality. We would like to be able to derive this new property automatically from the system model and the original property.

\textbf{Related work.}
Many works consider \emph{unrealisable} set of requirements --- where conflicts mean that no satisfying implementation exists --- solving the problem by weakening specifications. Some use counterstrategies to strengthen assumptions~\cite{cavezza2020,alur2013a,maoz2019} in the \LTL{} fragment $GR(1)$, while others use heuristic-guided genetic algorithms to mutate assumptions and guarantees towards realisability~\cite{brizzio2023}. However, this is different from the problem of weakening specifications relative to an existing implementation, which we are concerned with. We use a counterexample-guided approach, which has been applied to a large variety of problems including abstraction refinement~\cite{clarke2000,aarts2012,howar2011}, program synthesis~\cite{alur2013}, and learning assumptions for compositional verification~\cite{cobleigh2003}, but not yet to the problem of specification repair in the presence of an existing implementation. This has been explored using techniques from the field of program repair~\cite{gazzola2018}, typically heuristically-guided \emph{generate-and-validate} approaches like mutation-based repairs~\cite{cerqueira2022} and dynamic invariant detection~\cite{abreu2023a}. We, however, are concerned with correct-by-construction, \emph{semantics-driven} approaches, which have only been explored in the case of propositional logic specifications~\cite{andrew2026}.

\textbf{Contribution.}
We present our Counterexample-Guided Interval Weakening (\cegiw) algorithm that, given a degraded system and a desired \MTL{} property $\phi$ that does not hold on the system, produces a new optimal \MTL{} property $\phi'$ that both is weakening of $\phi$ and holds in the degraded system. We use a counterexample-guided approach, generating counterexamples with the \nuXmv{} model checker~\cite{cavada2014}, weakening the property to hold on the counterexamples, and iteratively weakening in this way until the property holds in the system. This approach is aimed at engineers in the design phase of safety-critical systems, who are trying to understand how resilient the timing properties of their system are to various proposed degradations, and how the system's formal guarantees are thus impacted.

The paper is organised as follows: \cref{sec:contexts} sets up the weakening of \MTL{} formulae within contexts, \cref{sec:algorithm} describes \cegiw{} and proves its correctness and optimality, \cref{sec:evaluation} demonstrates \cegiw{} on an example and considers its usefulness in real-world case-studies, and \cref{sec:conclusion} concludes and outlines future work.
