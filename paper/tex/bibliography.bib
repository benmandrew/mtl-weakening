@inproceedings{aarts2012,
  title = {Automata {{Learning}} through {{Counterexample Guided Abstraction Refinement}}},
  booktitle = {{{Formal Methods}}},
  author = {Aarts, Fides and Heidarian, Faranak and Kuppens, Harco and Olsen, Petur and Vaandrager, Frits},
  editor = {Giannakopoulou, Dimitra and M{\'e}ry, Dominique},
  year = 2012,
  pages = {10--27},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  %doi = {10.1007/978-3-642-32759-9_4},
  abstract = {Abstraction is the key when learning behavioral models of realistic systems. Hence, in most practical applications where automata learning is used to construct models of software components, researchers manually define abstractions which, depending on the history, map a large set of concrete events to a small set of abstract events that can be handled by automata learning tools. In this article, we show how such abstractions can be constructed fully automatically for a restricted class of extended finite state machines in which one can test for equality of data parameters, but no operations on data are allowed. Our approach uses counterexample-guided abstraction refinement: whenever the current abstraction is too coarse and induces nondeterministic behavior, the abstraction is refined automatically. Using Tomte, a prototype tool implementing our algorithm, we have succeeded to learn -- fully automatically -- models of several realistic software components, including the biometric passport and the SIP protocol.},
  isbn = {978-3-642-32759-9},
  langid = {english},
  keywords = {Automaton Learn,Equivalence Query,Input Symbol,Output Symbol,Session Initiation Protocol},
  file = {/home/y19056ba/Zotero/storage/QA3NB7IF/Aarts et al. - 2012 - Automata Learning through Counterexample Guided Abstraction Refinement.pdf}
}

@inproceedings{abreu2023a,
  title = {Exploring {{Automatic Specification Repair}} in {{Dafny Programs}}},
  booktitle = {{International Conference on Automated Software Engineering Workshops}},
  author = {Abreu, Alexandre and Macedo, Nuno and Mendes, Alexandra},
  year = 2023,
  month = sep,
  pages = {105--112},
  issn = {2151-0849},
 % doi = {10.1109/ASEW60602.2023.00019},
  urldate = {2024-11-27},
  abstract = {Formal verification has become increasingly crucial in ensuring the accurate and secure functioning of modern software systems. Given a specification of the desired behaviour, i.e. a contract, a program is considered to be correct when all possible executions guarantee the specification. Should the software fail to behave as expected, then a bug is present. Most existing research assumes that the bug is present in the implementation, but it is also often the case that the specified expectations are incorrect, meaning that it is the specification that must be repaired. Research and tools for providing alternative specifications that fix details missing during contract definition, considering that the implementation is correct, are scarce. This paper presents a preliminary tool, focused on Dafny programs, for automatic specification repair in contract programming. Given a Dafny program that fails to verify, the tool suggests corrections that repair the specification. Our approach is inspired by a technique previously proposed for another contract programming language and relies on Daikon for dynamic invariant inference. Although the tool is focused on Dafny, it makes use of specification repair techniques that are generally applicable to programming languages that support contracts. Such a tool can be valuable in various scenarios, such as when programmers have a reference implementation and need to analyse their contract options, or in educational contexts, where it can provide students with hints to correct their contracts. The results of the evaluation show that the approach is feasible in Dafny and that the overall process has reasonable performance but that there are stages of the process that need further imnrovements.},
  keywords = {automatic program repair,Computer bugs,Computer languages,Conferences,contract programming,contract repair,Contracts,Dafny,Dynamic programming,Maintenance engineering,Software systems},
  file = {/home/y19056ba/Zotero/storage/HFXX45XC/Abreu et al. - 2023 - Exploring Automatic Specification Repair in Dafny Programs.pdf;/home/y19056ba/Zotero/storage/LJZ2P47L/10298767.html}
}

@misc{akshay2025,
  title = {Efficient {{Verification}} of {{Metric Temporal Properties}} with {{Past}} in {{Pointwise Semantics}}},
  author = {Akshay, S. and Contractor, Prerak and Gastin, Paul and Govind, R. and Srivathsan, B.},
  year = 2025,
  month = oct,
  journal = {arXiv.org},
  urldate = {2025-11-24},
  abstract = {Model checking for real-timed systems is a rich and diverse topic. Among the different logics considered, Metric Interval Temporal Logic (MITL) is a powerful and commonly used logic, which can succinctly encode many interesting timed properties especially when past and future modalities are used together. In this work, we develop a new approach for MITL model checking in the pointwise semantics, where our focus is on integrating past and maximizing determinism in the translated automata. Towards this goal, we define synchronous networks of timed automata with shared variables and show that the past fragment of MITL can be translated in linear time to synchronous networks of deterministic timed automata. Moreover determinism can be preserved even when the logic is extended with future modalities at the top-level of the formula. We further extend this approach to the full MITL with past, translating it into networks of generalized timed automata (GTA) with future clocks (which extend timed automata and event clock automata). We present an SCC-based liveness algorithm to analyse GTA. We implement our translation in a prototype tool which handles both finite and infinite timed words and supports past modalities. Our experimental evaluation demonstrates that our approach significantly outperforms the state-of-the-art in MITL satisfiability checking in pointwise semantics on a benchmark suite of 72 formulas. Finally, we implement an end-to-end model checking algorithm for pointwise semantics and demonstrate its effectiveness on two well-known benchmarks.},
  howpublished = {https://arxiv.org/abs/2510.14699v1},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/3RWC9PUK/Akshay et al. - 2025 - Efficient Verification of Metric Temporal Properties with Past in Pointwise Semantics.pdf}
}

@article{alur1993,
  title = {Real-{{Time Logics}}: {{Complexity}} and {{Expressiveness}}},
  shorttitle = {Real-{{Time Logics}}},
  author = {Alur, Rajeev and Henzinger, Thomas A.},
  year = 1993,
  month = may,
  journal = {Information and Computation},
  volume = {104},
  number = {1},
  pages = {35--77},
  issn = {0890-5401},
 % doi = {10.1006/inco.1993.1025},
  urldate = {2025-11-18},
  abstract = {The theory of the natural numbers with linear order and monadic predicates underlies propositional linear temporal logic. To study temporal logics that are suitable for reasoning about real-time systems, we combine this classical theory of infinite state sequences with a theory of discrete time, via a monotonic function that maps every state to its time. The resulting theory of timed state sequences is shown to be decidable, albeit nonelementary, and its expressive power is characterized by {$\omega$}-regular sets. Several more expressive variants are proved to be highly undecidable. This framework allows us to classify a wide variety of real-time logics according to their complexity and expressiveness. Indeed, it follows that most formalisms proposed in the literature cannot be decided. We are, however, able to identify two elementary real-time temporal logics as expressively complete fragments of the theory of timed state sequences, and we present tableau-based decision procedures for checking validity. Consequently, these two formalisms are well-suited for the specification and verification of real-time systems.},
  file = {/home/y19056ba/Zotero/storage/T99UTBF6/Alur and Henzinger - 1993 - Real-Time Logics Complexity and Expressiveness.pdf;/home/y19056ba/Zotero/storage/HRRLXPLT/S0890540183710254.html}
}

@inproceedings{alur2013,
  title = {Syntax-Guided Synthesis},
  booktitle = {{{Formal Methods}} in {{Computer-Aided Design}}},
  author = {Alur, Rajeev and Bodik, Rastislav and Juniwal, Garvit and Martin, Milo M. K. and Raghothaman, Mukund and Seshia, Sanjit A. and Singh, Rishabh and {Solar-Lezama}, Armando and Torlak, Emina and Udupa, Abhishek},
  year = 2013,
  month = oct,
  pages = {1--8},
 % doi = {10.1109/FMCAD.2013.6679385},
  urldate = {2025-01-10},
  abstract = {The classical formulation of the program-synthesis problem is to find a program that meets a correctness specification given as a logical formula. Recent work on program synthesis and program optimization illustrates many potential benefits of allowing the user to supplement the logical specification with a syntactic template that constrains the space of allowed implementations. Our goal is to identify the core computational problem common to these proposals in a logical framework. The input to the syntax-guided synthesis problem (SyGuS) consists of a background theory, a semantic correctness specification for the desired program given by a logical formula, and a syntactic set of candidate implementations given by a grammar. The computational problem then is to find an implementation from the set of candidate expressions so that it satisfies the specification in the given theory. We describe three different instantiations of the counter-example-guided-inductive-synthesis (CEGIS) strategy for solving the synthesis problem, report on prototype implementations, and present experimental results on an initial set of benchmarks.},
  keywords = {Concrete,Grammar,Heuristic algorithms,Libraries,Production,Search problems,Syntactics},
  file = {/home/y19056ba/Zotero/storage/P77STNPH/Alur et al. - 2013 - Syntax-guided synthesis.pdf;/home/y19056ba/Zotero/storage/7TE7KAJ8/6679385.html}
}

@inproceedings{alur2013a,
  title = {Counter-Strategy Guided Refinement of {{GR}}(1) Temporal Logic Specifications},
  booktitle = {{{Formal Methods}} in {{Computer-Aided Design}}},
  author = {Alur, Rajeev and Moarref, Salar and Topcu, Ufuk},
  year = 2013,
  month = oct,
  pages = {26--33},
 % doi = {10.1109/FMCAD.2013.6679387},
  urldate = {2025-05-19},
  abstract = {The reactive synthesis problem is to find a finite-state controller that satisfies a given temporal-logic specification regardless of how its environment behaves. Developing a formal specification is a challenging and tedious task and initial specifications are often unrealizable. In many cases, the source of unrealizability is the lack of adequate assumptions on the environment of the system. In this paper, we consider the problem of automatically correcting an unrealizable specification given in the generalized reactivity (1) fragment of linear temporal logic by adding assumptions on the environment. When a temporal-logic specification is unrealizable, the synthesis algorithm computes a counter-strategy as a witness. Our algorithm then analyzes this counter-strategy and synthesizes a set of candidate environment assumptions that can be used to remove the counter-strategy from the environment's possible behaviors. We demonstrate the applicability of our approach with several case studies.},
  keywords = {Abstracts,Algorithm design and analysis,Educational institutions,Games,Polynomials,Transducers},
  file = {/home/y19056ba/Zotero/storage/H2N2MKYX/Alur et al. - 2013 - Counter-strategy guided refinement of GR(1) temporal logic specifications.pdf;/home/y19056ba/Zotero/storage/PLNN6MWV/6679387.html}
}

@inproceedings{andrew2026,
  title = {Weakening {{Goals}} in~{{Logical Specifications}}},
  booktitle = {Rigorous {{State-Based Methods}}},
  author = {Andrew, Ben M.},
  editor = {Leuschel, Michael and Ishikawa, Fuyuki},
  year = 2026,
  pages = {349--353},
  publisher = {Springer},
  address = {Cham},
 % doi = {10.1007/978-3-031-94533-5_22},
  abstract = {Logical specifications are widely used to represent software systems and their desired properties. Under system degradation or environmental changes, commonly seen in complex real-world robotic systems, these properties may no longer hold and so traditional verification methods will simply fail to construct a proof. However, weaker versions of these properties do still hold and can be useful for understanding the system's behaviour in uncertain conditions, as well as aiding compositional verification. We present a counterexample-guided technique for iteratively weakening properties, apply it to propositional logic specifications, and discuss planned extensions to state-based representations.},
  isbn = {978-3-031-94533-5},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/BHN8ERH9/Andrew - 2026 - Weakening Goals in Logical Specifications.pdf}
}

@article{angluin1987,
  title = {Learning Regular Sets from Queries and Counterexamples},
  author = {Angluin, Dana},
  year = 1987,
  month = nov,
  journal = {Information and Computation},
  volume = {75},
  number = {2},
  pages = {87--106},
  issn = {0890-5401},
  doi = {10.1016/0890-5401(87)90052-6},
  urldate = {2025-01-07},
  abstract = {The problem of identifying an unknown regular set from examples of its members and nonmembers is addressed. It is assumed that the regular set is presented by a minimally adequate Teacher, which can answer membership queries about the set and can also test a conjecture and indicate whether it is equal to the unknown set and provide a counterexample if not. (A counterexample is a string in the symmetric difference of the correct set and the conjectured set.) A learning algorithm L{$\ast$} is described that correctly learns any regular set from any minimally adequate Teacher in time polynomial in the number of states of the minimum dfa for the set and the maximum length of any counterexample provided by the Teacher. It is shown that in a stochastic setting the ability of the Teacher to test conjectures may be replaced by a random sampling oracle, EX( ). A polynomial-time learning algorithm is shown for a particular problem of context-free language identification.},
  file = {/home/y19056ba/Zotero/storage/4IVEEI66/Angluin - 1987 - Learning regular sets from queries and counterexamples.pdf;/home/y19056ba/Zotero/storage/RP2F85GZ/0890540187900526.html}
}

@book{baier2008a,
  title = {Principles of {{Model Checking}}},
  author = {Baier, Christel and Katoen, Joost-Pieter},
  year = 2008,
  month = apr,
  publisher = {MIT Press},
  abstract = {A comprehensive introduction to the foundations of model checking, a fully automated technique for finding flaws in hardware and software; with extensive examples and both practical and theoretical exercises.Our growing dependence on increasingly complex computer and software systems necessitates the development of formalisms, techniques, and tools for assessing functional properties of these systems. One such technique that has emerged in the last twenty years is model checking, which systematically (and automatically) checks whether a model of a given system satisfies a desired property such as deadlock freedom, invariants, and request-response properties. This automated technique for verification and debugging has developed into a mature and widely used approach with many applications. Principles of Model Checking offers a comprehensive introduction to model checking that is not only a text suitable for classroom use but also a valuable reference for researchers and practitioners in the field.The book begins with the basic principles for modeling concurrent and communicating systems, introduces different classes of properties (including safety and liveness), presents the notion of fairness, and provides automata-based algorithms for these properties. It introduces the temporal logics LTL and CTL, compares them, and covers algorithms for verifying these logics, discussing real-time systems as well as systems subject to random phenomena. Separate chapters treat such efficiency-improving techniques as abstraction and symbolic manipulation. The book includes an extensive set of examples (most of which run through several chapters) and a complete set of basic results accompanied by detailed proofs. Each chapter concludes with a summary, bibliographic notes, and an extensive list of exercises of both practical and theoretical nature.},
  googlebooks = {5dvxCwAAQBAJ},
  isbn = {978-0-262-30403-0},
  langid = {english},
  keywords = {Computers / Operating Systems / General,Computers / Programming / Algorithms},
  file = {/home/y19056ba/Zotero/storage/PHNZLM6K/Baier and Katoen - 2008 - Principles of Model Checking.pdf}
}

@inproceedings{bourbouh2021,
  title = {Integrating {{Formal Verification}} and {{Assurance}}: {{An Inspection Rover Case Study}}},
  shorttitle = {Integrating {{Formal Verification}} and {{Assurance}}},
  booktitle = {{{NASA Formal Methods}}},
  author = {Bourbouh, Hamza and Farrell, Marie and Mavridou, Anastasia and Sljivo, Irfan and Brat, Guillaume and Dennis, Louise A. and Fisher, Michael},
  editor = {Dutle, Aaron and Moscato, Mariano M. and Titolo, Laura and Mu{\~n}oz, C{\'e}sar A. and Perez, Ivan},
  year = 2021,
  %volume = {12673},
  pages = {53--71},
  publisher = {Springer International Publishing},
  address = {Cham},
  %doi = {10.1007/978-3-030-76384-8_4},
  urldate = {2024-10-23},
  abstract = {The complexity and flexibility of autonomous robotic systems necessitates a range of distinct verification tools. This presents new challenges not only for design verification but also for assurance approaches. Combining the distinct formal verification tools, while maintaining sufficient formal coherence to provide compelling assurance evidence is difficult, often being abandoned for less formal approaches. In this paper we demonstrate, through a case study, how a variety of distinct formal techniques can be brought together in order to develop a justifiable assurance case. We use the AdvoCATE assurance case tool to guide our analyses and to integrate the artifacts from the formal methods that we use, namely: fret, cocosim and Event-B. While we present our methodology as applied to a specific Inspection Rover case study, we believe that this combination provides benefits in maintaining coherent formal links across development and assurance processes for a wide range of autonomous robotic systems.},
  isbn = {978-3-030-76383-1 978-3-030-76384-8},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/9AQCEPTK/Bourbouh et al. - 2021 - Integrating Formal Verification and Assurance An Inspection Rover Case Study.pdf}
}

@inproceedings{brihaye2018,
  title = {Efficient {{Algorithms}} and {{Tools}} for {{MITL Model-Checking}} and {{Synthesis}}},
  booktitle = {{International Conference on Engineering of Complex Computer Systems}},
  author = {Brihaye, Thomas and Geeraerts, Gilles and Ho, Hsi-Ming and Milchior, Arthur and Monmege, Benjamin},
  year = 2018,
  month = dec,
  pages = {180--184},
  %doi = {10.1109/ICECCS2018.2018.00027},
  urldate = {2025-11-24},
  abstract = {Metric Interval Temporal Logic (MITL) is an extension of the classical Linear Time Logic (LTL) that can be used to characterise real-time properties of computer systems. While the practical interest of MITL is undeniable, there is still today a remarkable lack of tool support for this logic. In this short paper, we report on our on-going work effort to complete the theoretical knowledge about MITL. We also report on our recently introduced tool MightyL, which translates MITL formulae into timed automata, enabling efficient model-checking of this logic. Finally, we sketch the future directions of our current line of research, which will be to extend MightyL to support reactive synthesis of MITL properties.},
  keywords = {Automata,Clocks,Computational modeling,Cost accounting,MITL,Model-checking,Real-time systems,Semantics,Synthesis,Timed automata,Tools},
  file = {/home/y19056ba/Zotero/storage/PIUAIP2Y/Brihaye et al. - 2018 - Efficient Algorithms and Tools for MITL Model-Checking and Synthesis.pdf;/home/y19056ba/Zotero/storage/U8M5G95L/8595072.html}
}

@inproceedings{brizzio2023,
  title = {Automated {{Repair}} of {{Unrealisable LTL Specifications Guided}} by {{Model Counting}}},
  booktitle = {{{Genetic}} and {{Evolutionary Computation Conference}}},
  author = {Brizzio, Mat{\'i}as and Cordy, Maxime and Papadakis, Mike and S{\'a}nchez, C{\'e}sar and Aguirre, Nazareno and Degiovanni, Renzo},
  year = 2023,
  month = jul,
  pages = {1499--1507},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  %doi = {10.1145/3583131.3590454},
  urldate = {2025-05-24},
  abstract = {The reactive synthesis problem consists of automatically producing correct-by-construction operational models of systems from high-level formal specifications of their behaviours. However, specifications are often unrealisable, meaning that no system can be synthesised from the specification. To deal with this problem, we present AuRUS, a search-based approach to repair unrealisable Linear-Time Temporal Logic (LTL) specifications. AuRUS aims at generating solutions that are similar to the original specifications by using the notions of syntactic and semantic similarities. Intuitively, the syntactic similarity measures the text similarity between the specifications, while the semantic similarity measures the number of behaviours preserved/removed by the candidate repair. We propose a new heuristic based on model counting to approximate semantic similarity. We empirically assess AuRUS on many unrealisable specifications taken from different benchmarks and show that it can successfully repair all of them. Also, compared to related techniques, AuRUS can produce many unique solutions while showing more scalability.},
  isbn = {979-8-4007-0119-1},
  file = {/home/y19056ba/Zotero/storage/3UP4BE2E/Brizzio et al. - 2023 - Automated Repair of Unrealisable LTL Specifications Guided by Model Counting.pdf}
}

@inproceedings{brizzio2024,
  title = {Resolving {{Goal-Conflicts}} and {{Scaling Synthesis}} through {{Mode-Based Decomposition}}},
  booktitle = {Proceedings of the 2024 {{IEEE}}/{{ACM}} 46th {{International Conference}} on {{Software Engineering}}: {{Companion Proceedings}}},
  author = {Brizzio, Mat{\'i}as},
  year = 2024,
  month = may,
  series = {{{ICSE-Companion}} '24},
  pages = {207--211},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3639478.3639801},
  urldate = {2025-11-29},
  abstract = {Reactive synthesis, with its roots in the work of A. Church, presents a transformative approach for the formal methods community. It seeks to translate system behaviors expressed in Linear-Time Temporal Logic (LTL) into correct-by-construction models using synthesis tools. However, this approach faces substantial challenges. Among these challenges is the high computational complexity of LTL synthesis, which constrains its application to large-scale systems. Additionally, unrealizable specifications present a significant obstacle as they act as barriers, impeding the synthesis process. Furthermore, the presence of goal-conflicts within requirements introduces contradictions and ambiguity, further complicating the synthesis process. These issues collectively make synthesis demanding, often resulting in suboptimal or unviable systems.Our research is dedicated to establishing a robust framework that systematically addresses these challenges, effectively bridging the gap between high-level requirements and dependable system realization. We prioritize refining requirement precision and advancing scalable synthesis techniques, offering advanced tools and methodologies to practitioners and researchers.},
  isbn = {979-8-4007-0502-1},
  file = {/home/y19056ba/Zotero/storage/FSJLG9F6/Brizzio - 2024 - Resolving Goal-Conflicts and Scaling Synthesis through Mode-Based Decomposition.pdf}
}

@inproceedings{cavada2014,
  title = {The {{\textsc{nuXmv} Symbolic Model Checker}}},
  booktitle = {Computer {{Aided Verification}}},
  author = {Cavada, Roberto and Cimatti, Alessandro and Dorigatti, Michele and Griggio, Alberto and Mariotti, Alessandro and Micheli, Andrea and Mover, Sergio and Roveri, Marco and Tonetta, Stefano},
  editor = {Biere, Armin and Bloem, Roderick},
  year = 2014,
  pages = {334--342},
  publisher = {Springer International Publishing},
  address = {Cham},
 % doi = {10.1007/978-3-319-08867-9_22},
  abstract = {This paper describes the nuXmv symbolic model checker for finite- and infinite-state synchronous transition systems. nuXmv is the evolution of the nuXmv open source model checker. It builds on and extends nuXmv along two main directions. For finite-state systems it complements the basic verification techniques of nuXmv with state-of-the-art verification algorithms. For infinite-state systems, it extends the nuXmv language with new data types, namely Integers and Reals, and it provides advanced SMT-based model checking techniques.},
  isbn = {978-3-319-08867-9},
  langid = {english},
  keywords = {Model Check,Model Check Problem,Predicate Abstraction,Software Model Check,Symbolic Model Checker},
  file = {/home/y19056ba/Zotero/storage/NH4Z8UQL/Cavada et al. - 2014 - The nuXmv Symbolic Model Checker.pdf}
}

@inproceedings{cavezza2020,
  title = {Minimal {{Assumptions Refinement}} for {{Realizable Specifications}}},
  booktitle = {{{International Conference}} on {{Formal Methods}} in {{Software Engineering}}},
  author = {Cavezza, Davide G. and Alrajeh, Dalal and Gy{\"o}rgy, Andr{\'a}s},
  year = 2020,
  month = oct,
  %series = {{{FormaliSE}} '20},
  pages = {66--76},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  %doi = {10.1145/3372020.3391557},
  urldate = {2025-05-14},
  abstract = {A challenge that has gathered much attention in recent years is automated synthesis of correct-by-construction software systems from declarative specifications. The specification language is typically a subset of linear temporal logic called generalized reactivity of rank 1, for which there exists an efficient synthesis algorithm. Specifications in this language model the system as the interaction between an environment and a controller, the former satisfying a set of assumptions and the latter a set of guarantees. In order for a solution to exist, a sufficient set of assumptions implying the guarantees must be provided. The assumptions must be as general as possible and small enough to be intelligible by engineers that need to assess their consistency with the true environment where the synthesized controller will operate.The search for such assumptions is generally a refinement approach driven by counterstrategies, characterizations of undesirable environment behaviors that force the violation of the guarantees; assumptions are progressively refined in order to exclude such behaviors. In this work we provide a heuristic to drive this counterstrategy-guided search towards smaller refinements. We define a concept of minimality of refinements with respect to counterstrategies and provide an algorithm that provably finds minimal refinements with little time overhead. We show experimentally that it consistently produces one or more shorter solutions than state of the art for a set of popular case studies. We also demonstrate that in a popular case study (AMBA-AHB protocol) our heuristic finds a close-to-optimal solution that cannot be found by previous fully automated approaches.},
  isbn = {978-1-4503-7071-4},
  file = {/home/y19056ba/Zotero/storage/X8TFU263/Cavezza et al. - 2020 - Minimal Assumptions Refinement for Realizable Specifications.pdf}
}

@inproceedings{cerqueira2022,
  title = {Timely {{Specification Repair}} for {{Alloy}} 6},
  booktitle = {Software {{Engineering}} and {{Formal Methods}}},
  author = {Cerqueira, Jorge and Cunha, Alcino and Macedo, Nuno},
  editor = {Schlingloff, Bernd-Holger and Chai, Ming},
  year = 2022,
  pages = {288--303},
  publisher = {Springer International Publishing},
  address = {Cham},
  %doi = {10.1007/978-3-031-17108-6_18},
  abstract = {This paper proposes the first mutation-based technique for the repair of Alloy 6 first-order temporal logic specifications. This technique was developed with the educational context in mind, in particular, to repair submissions for specification challenges, as allowed, for example, in the Alloy4Fun web-platform. Given an oracle and an incorrect submission, the proposed technique searches for syntactic mutations that lead to a correct specification, using previous counterexamples to quickly prune the search space, thus enabling timely feedback to students. Evaluation shows that, not only is the technique feasible for repairing temporal logic specifications, but also outperforms existing techniques for non-temporal Alloy specifications in the context of educational challenges.},
  isbn = {978-3-031-17108-6},
  langid = {english},
  keywords = {Alloy,First-order temporal logic,Formal methods education,Specification repair},
  file = {/home/y19056ba/Zotero/storage/254RAXET/Cerqueira et al. - 2022 - Timely Specification Repair for Alloy 6.pdf}
}

@inproceedings{clarke2000,
  title = {Counterexample-{{Guided Abstraction Refinement}}},
  booktitle = {Computer {{Aided Verification}}},
  author = {Clarke, Edmund and Grumberg, Orna and Jha, Somesh and Lu, Yuan and Veith, Helmut},
  editor = {Emerson, E. Allen and Sistla, Aravinda Prasad},
  year = 2000,
  pages = {154--169},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  %doi = {10.1007/10722167_15},
  abstract = {We present an automatic iterative abstraction-refinement methodology in which the initial abstract model is generated by an automatic analysis of the control structures in the program to be verified. Abstract models may admit erroneous (or ``spurious'') counterexamples. We devise new symbolic techniques which analyze such counterexamples and refine the abstract model correspondingly. The refinement algorithm keeps the size of the abstract state space small due to the use of abstraction functions which distinguish many degrees of abstraction for each program variable. We describe an implementation of our methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches and 10000 lines of SMV code confirm the effectiveness of our approach.},
  isbn = {978-3-540-45047-4},
  langid = {english},
  keywords = {Abstract Model,Atomic Formula,Kripke Structure,Localization Reduction,Model Check},
  file = {/home/y19056ba/Zotero/storage/RNMC5FTY/Clarke et al. - 2000 - Counterexample-Guided Abstraction Refinement.pdf}
}

@incollection{clarke2004a,
  title = {Completeness and {{Complexity}} of {{Bounded Model Checking}}},
  booktitle = {Verification, {{Model Checking}}, and {{Abstract Interpretation}}},
  author = {Clarke, Edmund and Kroening, Daniel and Ouaknine, Jo{\"e}l and Strichman, Ofer},
  editor = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan and Steffen, Bernhard and Levi, Giorgio},
  year = 2004,
 % volume = {2937},
  pages = {85--96},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-24622-0_9},
  urldate = {2025-11-19},
  abstract = {For every finite model M and an LTL property {$\phi$}, there exists a number CT (the Completeness Threshold ) such that if there is no counterexample to {$\phi$} in M of length CT or less, then M \textbar = {$\phi$}. Finding this number, if it is sufficiently small, offers a practical method for making Bounded Model Checking complete. We describe how to compute an over-approximation to CT for a general LTL property using B\textasciidieresis uchi automata, following the Vardi-Wolper LTL model checking framework. Based on the value of CT , we prove that the complexity of standard SAT-based BMC is doubly exponential, and that consequently there is a complexity gap of an exponent between this procedure and standard LTL model checking. We discuss ways to bridge this gap.},
  isbn = {978-3-540-20803-7 978-3-540-24622-0},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/5BRZ2EPF/Clarke et al. - 2004 - Completeness and Complexity of Bounded Model Checking.pdf}
}

@book{clarke2018,
  title = {Handbook of {{Model Checking}}},
  editor = {Clarke, Edmund M. and Henzinger, Thomas A. and Veith, Helmut and Bloem, Roderick},
  year = 2018,
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-10575-8},
  urldate = {2024-09-26},
  copyright = {http://www.springer.com/tdm},
  isbn = {978-3-319-10574-1 978-3-319-10575-8},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/UL47P3AJ/Clarke et al. - 2018 - Handbook of Model Checking.pdf}
}

@incollection{cobleigh2003,
  title = {Learning {{Assumptions}} for {{Compositional Verification}}},
  booktitle = {Tools and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
  author = {Cobleigh, Jamieson M. and Giannakopoulou, Dimitra and P{\u a}s{\u a}reanu, Corina S.},
  editor = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan and Garavel, Hubert and Hatcliff, John},
  year = 2003,
 % volume = {2619},
  pages = {331--346},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
 % doi = {10.1007/3-540-36577-X_24},
  urldate = {2025-01-06},
  abstract = {Compositional verification is a promising approach toaddressing the state explosion problem associated wihh model checking. One composition\_ technique advocates proving properties of a system by checking properties of its components in an assume-guarantee ......... s\_le. However, the application of thistech\_ique is \_\_fficult because it involves non-trivial human input. This paper presents a novel framework for performing assume-guarantee reasoning in an incremental and fully automated fashion. To check a component against a property, our approach generates assumptions that the environment needs to satisfy for the property to hold. These assumptions are then discharged on the rest of the system. Assumptions are computed by a learning algorithm. They are initially approximate, but become \_adually more precise by means of counterexamples obtained by model checking the component and its environment, alternately. This iterative process may at any stage conclude that the property is either true or false in the system. We have implemented our approach in the LTSA tool and applied it to the analysis of a NASA system.},
  isbn = {978-3-540-00898-9 978-3-540-36577-8},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/F5DG3MRS/Cobleigh et al. - 2003 - Learning Assumptions for Compositional Verification.pdf}
}

@inproceedings{degiacomo2013,
  title = {Linear {{Temporal Logic}} and {{Linear Dynamic Logic}} on {{Finite Traces}}},
  booktitle = {Proceedings of the {{Twenty-Third}} International Joint Conference on {{Artificial Intelligence}}},
  author = {De Giacomo, Giuseppe and Vardi, Moshe Y.},
  year = 2013,
  month = aug,
  series = {{{IJCAI}} '13},
  pages = {854--860},
  publisher = {AAAI Press},
  address = {Beijing, China},
  urldate = {2025-10-10},
  abstract = {In this paper we look into the assumption of interpreting LTL over finite traces. In particular we show that LTLf, i.e., LTL under this assumption, is less expressive than what might appear at first sight, and that at essentially no computational cost one can make a significant increase in expressiveness while maintaining the same intuitiveness of LTLf. Indeed, we propose a logic, LDLf for Linear Dynamic Logic over finite traces, which borrows the syntax from Propositional Dynamic Logic (PDL), but is interpreted over finite traces. Satisfiability, validity and logical implication (as well as model checking) for LTLf. are PSPACE-complete as for LTLf. (and LTL).},
  isbn = {978-1-57735-633-2},
  file = {/home/y19056ba/Zotero/storage/ABW5PEUY/De Giacomo and Vardi - 2013 - Linear temporal logic and linear dynamic logic on finite traces.pdf}
}

@inproceedings{ehlers2019,
  title = {How {{Hard Is Finding Shortest Counter-Example Lassos}} in {{Model Checking}}?},
  booktitle = {Formal {{Methods}} -- {{The Next}} 30 {{Years}}},
  author = {Ehlers, R{\"u}diger},
  editor = {{ter Beek}, Maurice H. and McIver, Annabelle and Oliveira, Jos{\'e} N.},
  year = 2019,
  pages = {245--261},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-30942-8_16},
  abstract = {Modern model checkers help system engineers to pinpoint the reason for the faulty behavior of a system by providing counter-example traces. For finite-state systems and \$\$\textbackslash omega \$\${$\omega$}-regular specifications, they come in the form of lassos. Lassos that are unnecessarily long should be avoided, as they make finding the cause for an error in a trace harder.},
  isbn = {978-3-030-30942-8},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/TL3ZBMI5/Ehlers - 2019 - How Hard Is Finding Shortest Counter-Example Lassos in Model Checking.pdf}
}

@inproceedings{farrell2022,
  title = {{{FRETting About Requirements}}: {{Formalised Requirements}} for~an~{{Aircraft Engine Controller}}},
  shorttitle = {{{FRETting About Requirements}}},
  booktitle = {Requirements {{Engineering}}: {{Foundation}} for {{Software Quality}}},
  author = {Farrell, Marie and Luckcuck, Matt and Sheridan, Ois{\'i}n and Monahan, Rosemary},
  editor = {Gervasi, Vincenzo and Vogelsang, Andreas},
  year = 2022,
  pages = {96--111},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-98464-9_9},
  abstract = {[Context \& motivation] Eliciting requirements that are detailed and logical enough to be amenable to formal verification is a difficult task. Multiple tools exist for requirements elicitation and some of these also support formalisation of requirements in a way that is useful for formal methods. [Question/problem] This paper reports on our experience of using the Formal Requirements Elicitation Tool (FRET) alongside our industrial partner. The use case that we investigate is an aircraft engine controller. In this context, we evaluate the use of FRET to bridge the communication gap between formal methods experts and aerospace industry specialists. [Principal ideas/results] We describe our journey from ambiguous, natural-language requirements to concise, formalised FRET requirements. We include our analysis of the formalised requirements from the perspective of patterns, translation into other formal methods and the relationship between parent-child requirements in this set. We also provide insight into lessons learned throughout this process and identify future improvements to FRET. [Contribution] Previous experience reports have been published by the FRET team, but this is the first such report of an industrial use case that was written by researchers that have not been involved FRET's development.},
  isbn = {978-3-030-98464-9},
  langid = {english},
  keywords = {Formal requirements,FRET,Traceability},
  file = {/home/y19056ba/Zotero/storage/3VGKH5FT/Farrell et al. - 2022 - FRETting About Requirements Formalised Requirements for an Aircraft Engine Controller.pdf}
}

@article{farrell2022a,
  title = {Formal {{Modelling}} and {{Runtime Verification}} of {{Autonomous Grasping}} for {{Active Debris Removal}}},
  author = {Farrell, Marie and Mavrakis, Nikos and Ferrando, Angelo and Dixon, Clare and Gao, Yang},
  year = 2022,
  month = jan,
  journal = {Frontiers in Robotics and AI},
  volume = {8},
  publisher = {Frontiers},
  issn = {2296-9144},
  doi = {10.3389/frobt.2021.639282},
  urldate = {2025-11-26},
  abstract = {Active debris removal in space has become a necessary activity to maintain and facilitate orbital operations. Current approaches tend to adopt autonomous robotic systems which are often furnished with a robotic arm to safely capture debris by identifying a suitable grasping point. These systems are controlled by mission-critical software, where a software failure can lead to mission failure which is difficult to recover from since the robotic systems are not easily accessible to humans. Therefore, verifying that these autonomous robotic systems function correctly is crucial. Formal verification methods enable us to analyse the software that is controlling these systems and to provide a proof of correctness that the software obeys its requirements. However, robotic systems tend not to be developed with verification in mind from the outset, which can often complicate the verification of the final algorithms and systems. In this paper, we describe the process that we used to verify a pre-existing system for autonomous grasping which is to be used for active debris removal in space. In particular, we formalise the requirements for this system using the Formal Requirements Elicitation Tool (FRET). We formally model specific software components of the system and formally verify that they adhere to their corresponding requirements using the Dafny program verifier. From the original FRET requirements, we synthesise runtime monitors using ROSMonitoring and show how these can provide runtime assurances for the system. We also describe our experimentation and analysis of the testbed and the associated simulation. We provide a detailed discussion of our approach and describe how the modularity of this particular autonomous system simplified the usually complex task of verifying a system post-development.},
  langid = {english},
  keywords = {Autonomous grasping,Formal methods (FMs),Formal Verification,Requirements Elicitacion,Runtime verification},
  file = {/home/y19056ba/Zotero/storage/B9PPTZ2L/Farrell et al. - 2022 - Formal Modelling and Runtime Verification of Autonomous Grasping for Active Debris Removal.pdf}
}

@inproceedings{farrell2024,
  title = {{{FRETting}} and~{{Formal Modelling}}: {{A Mechanical Lung Ventilator}}},
  shorttitle = {{{FRETting}} and~{{Formal Modelling}}},
  booktitle = {Rigorous {{State-Based Methods}}},
  author = {Farrell, Marie and Luckcuck, Matt and Monahan, Rosemary and Reynolds, Conor and Sheridan, Ois{\'i}n},
  editor = {Bonfanti, Silvia and Gargantini, Angelo and Leuschel, Michael and Riccobene, Elvinia and Scandurra, Patrizia},
  year = 2024,
  pages = {360--383},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-63790-2_28},
  abstract = {In this paper, we use NASA's Formal Requirements Elicitation Tool (FRET) and the Event-B formal method to model and verify the requirements for the ABZ 2024 case study, the Mechanical Lung Ventilator. We use the FRET requirements to guide the development of a formal design model in Event-B. We provide details about the artefacts produced and reflect on our experience of using these tools in this case study. We focus on the Functional and Controller requirements for the system, as given in the case study documentation. This paper provides a first step towards using Event-B as part of a FRET-guided verification workflow in a large case study.},
  isbn = {978-3-031-63790-2},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/QFP76UTK/Farrell et al. - 2024 - FRETting and Formal Modelling A Mechanical Lung Ventilator.pdf}
}

@inproceedings{gazzola2018,
  title = {Automatic Software Repair: A Survey},
  shorttitle = {Automatic Software Repair},
  booktitle = {{International Conference on Software Engineering}},
  author = {Gazzola, Luca and Micucci, Daniela and Mariani, Leonardo},
  year = 2018,
  month = may,
 % series = {{{ICSE}} '18},
  pages = {1219},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3180155.3182526},
  urldate = {2025-03-20},
  abstract = {Debugging software failures is still a painful, time consuming, and expensive process. For instance, recent studies showed that debugging activities often account for about 50\% of the overall development cost of software products [3]. There are many factors contributing to the cost of debugging, but the most impacting one is the extensive manual effort that is still required to identify and remove faults. So far, the automation of debugging activities essentially resulted in the development of techniques that provide useful insights about the possible locations of faults, the inputs and states of the application responsible for the failures, as well as the anomalous operations executed during failures. However, developers must still put a relevant effort on the analysis of the failed executions to exactly identify the faults that must be fixed. In addition, these techniques do not help the developers with the synthesis of an appropriate fix.},
  isbn = {978-1-4503-5638-1},
  file = {/home/y19056ba/Zotero/storage/U8K3Q4FP/Gazzola et al. - 2019 - Automatic Software Repair A Survey.pdf}
}

@inproceedings{giannakopoulou2020,
  title = {Generation of {{Formal Requirements}} from {{Structured Natural Language}}},
  booktitle = {Requirements {{Engineering}}: {{Foundation}} for {{Software Quality}}},
  author = {Giannakopoulou, Dimitra and Pressburger, Thomas and Mavridou, Anastasia and Schumann, Johann},
  editor = {Madhavji, Nazim and Pasquale, Liliana and Ferrari, Alessio and Gnesi, Stefania},
  year = 2020,
  pages = {19--35},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-44429-7_2},
  abstract = {[Motivation] The use of structured natural languages to capture requirements provides a reasonable trade-off between ambiguous natural language and unintuitive formal notations. [Problem] There are two major challenges in making structured natural language amenable to formal analysis: (1) associating requirements with formulas that can be processed by analysis tools and (2) ensuring that the formulas conform to the language semantics. [Results] FRETISH is a structured natural language that incorporates features from existing research and from NASA applications. Even though FRETISH is quite expressive, its underlying semantics is determined by the types of four fields: scope, condition, timing, and response. Each combination of field types defines a template with Real-Time Graphical Interval Logic (RTGIL) semantics. We present an approach that constructs future and past-time metric temporal logic formulas for each template compositionally, from its fields. To establish correctness of our approach we have developed a framework which, for each template: (1) extensively tests the generated formulas against the template semantics and (2) proves equivalence between its past-time and future-time formulas. Our approach has been used to capture and analyze requirements for a Lockheed Martin Cyber-Physical System challenge. [Contribution] To the best of our knowledge, this is the first approach to generate pure past-time and pure future-time formalizations to accommodate a variety of analysis tools. The compositional nature of our algorithms facilitates maintenance and extensibility, and our extensive verification framework establishes trust in the produced formalizations. Our approach is available through the open-source tool fret.},
  isbn = {978-3-030-44429-7},
  langid = {english},
  keywords = {Compositional formalization,Requirements elicitation,Structured natural languages,Temporal logics,Verification},
  file = {/home/y19056ba/Zotero/storage/33VGPNE2/Giannakopoulou et al. - 2020 - Generation of Formal Requirements from Structured Natural Language.pdf}
}

@article{giannakopoulou2020a,
  title = {Formal {{Requirements Elicitation}} with {{FRET}}},
  author = {Giannakopoulou, Dimitra and Pressburger, Thomas and Mavridou, Anastasia and Rhein, Julian and Schumann, Johann and Shi, Nija},
  year = 2020,
  journal = {International Working Conference on Requirements Engineering: Foundation for Software Quality},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/7AM4Y8P2/Giannakopoulou et al. - Formal Requirements Elicitation with FRET.pdf}
}

@article{giannakopoulou2021,
  title = {Automated Formalization of Structured Natural Language Requirements},
  author = {Giannakopoulou, Dimitra and Pressburger, Thomas and Mavridou, Anastasia and Schumann, Johann},
  year = 2021,
  month = sep,
  journal = {Information and Software Technology},
  volume = {137},
  pages = {106590},
  issn = {0950-5849},
  doi = {10.1016/j.infsof.2021.106590},
  urldate = {2025-04-23},
  abstract = {The use of structured natural languages to capture requirements provides a reasonable trade-off between ambiguous natural language and unintuitive formal notations. There are two major challenges in making structured natural language amenable to formal analysis: (1) formalizing requirements as formulas that can be processed by analysis tools and (2) ensuring that the formulas conform to the semantics of the structured natural language. fretish is a structured natural language that incorporates features from existing research and from NASA applications. Even though fretish is quite expressive, its underlying semantics is determined by the types of four fields: scope, condition, timing, and response. Each combination of field types defines a template with Real-Time Graphical Interval Logic (RTGIL) semantics. We have developed a framework that constructs temporal logic formulas for each template compositionally, from its fields. The compositional nature of our algorithms facilitates maintenance and extensibility. Our goal is to be inclusive not only in terms of language expressivity, but also in terms of requirements analysis tools that we can interface with. For this reason we generate metric-temporal logic formulas with (1) exclusively future-time operators, over both finite and infinite traces, and (2) exclusively past-time operators. To establish trust in the produced formalizations for each template, our framework: (1) extensively tests the generated formulas against the template semantics and (2) proves equivalence between its past-time and future-time formulas. Our approach is available through the open-source tool fret and has been used to capture and analyze requirements for a Lockheed Martin Cyber--Physical System challenge.},
  keywords = {Analysis,Requirements,Structured natural language,Temporal logic,Testing,Verification},
  file = {/home/y19056ba/Zotero/storage/CGKNCV6X/Giannakopoulou et al. - 2021 - Automated formalization of structured natural language requirements.pdf;/home/y19056ba/Zotero/storage/MM4LDGP3/S0950584921000707.html}
}

@inproceedings{grumberg2006,
  title = {Abstraction and {{Refinement}} in {{Model Checking}}},
  booktitle = {Formal {{Methods}} for {{Components}} and {{Objects}}},
  author = {Grumberg, Orna},
  editor = {{de Boer}, Frank S. and Bonsangue, Marcello M. and Graf, Susanne and {de Roever}, Willem-Paul},
  year = 2006,
  pages = {219--242},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/11804192_11},
  abstract = {In this paper we survey abstraction and refinement in model checking. We restrict the discussion to existential abstraction which over-approximates the behaviors of the concrete model. The logics preserved under this abstraction are the universal fragments of branching-time temporal logics as well as linear-time temporal logics. For simplicity of presentation, we also restrict the discussion to abstraction functions, rather then abstraction relations. Thus, every concrete state is represented by exactly one abstract state. An abstract state then represents a set of concrete states, which is disjoint from the sets represented by other abstract states.},
  isbn = {978-3-540-36750-5},
  langid = {english},
  keywords = {Abstract Model,Abstract State,Atomic Proposition,Concrete Model,Model Check},
  file = {/home/y19056ba/Zotero/storage/KRTS5N53/Grumberg - 2006 - Abstraction and Refinement in Model Checking.pdf}
}

@article{holzmann1997,
  title = {The Model Checker {{SPIN}}},
  author = {Holzmann, Gerard J.},
  year = 1997,
  month = may,
  journal = {IEEE Transactions on Software Engineering},
  volume = {23},
  number = {5},
  pages = {279--295},
  issn = {0098-5589, 1939-3520, 2326-3881},
  doi = {10.1109/32.588521},
  urldate = {2025-10-20},
  abstract = {SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. This paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.},
  copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/IF8XUM5R/Holzmann - 1997 - The model checker SPIN.pdf}
}

@inproceedings{howar2011,
  title = {Automata {{Learning}} with {{Automated Alphabet Abstraction Refinement}}},
  booktitle = {Verification, {{Model Checking}}, and {{Abstract Interpretation}}},
  author = {Howar, Falk and Steffen, Bernhard and Merten, Maik},
  editor = {Jhala, Ranjit and Schmidt, David},
  year = 2011,
  pages = {263--277},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-18275-4_19},
  abstract = {Abstraction is the key when learning behavioral models of realistic systems, but also the cause of a major problem: the introduction of non-determinism. In this paper, we introduce a method for refining a given abstraction to automatically regain a deterministic behavior on-the-fly during the learning process. Thus the control over abstraction becomes part of the learning process, with the effect that detected non-determinism does not lead to failure, but to a dynamic alphabet abstraction refinement. Like automata learning itself, this method in general is neither sound nor complete, but it also enjoys similar convergence properties even for infinite systems as long as the concrete system itself behaves deterministically, as illustrated along a concrete example.},
  isbn = {978-3-642-18275-4},
  langid = {english},
  keywords = {Automaton Learn,Concrete System,Input Alphabet,Membership Query,Model Check},
  file = {/home/y19056ba/Zotero/storage/XDSVDEH9/Howar et al. - 2011 - Automata Learning with Automated Alphabet Abstraction Refinement.pdf}
}

@misc{iso2023,
  type = {80601-2-12},
  title = {Particular Requirements for Basic Safety and Essential Performance of Critical Care Ventilators},
  shorttitle = {{{ISO}} 80601-2-12},
  author = {{ISO}},
  year = 2023,
  number = {80601-2-12},
  urldate = {2025-12-01},
  abstract = {Medical electrical equipment --- Part 2-12: Particular requirements for basic safety and essential performance of critical care ventilators},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/3TKP2E2T/82707.html}
}

@article{koymans1990,
  title = {Specifying Real-Time Properties with Metric Temporal Logic},
  author = {Koymans, Ron},
  year = 1990,
  month = nov,
  journal = {Real-Time Systems},
  volume = {2},
  number = {4},
  pages = {255--299},
  issn = {1573-1383},
  doi = {10.1007/BF01995674},
  urldate = {2025-11-27},
  abstract = {This paper is motivated by the need for a formal specification method for real-time systems. In these systemsquantitative temporal properties play a dominant role. We first characterize real-time systems by giving a classification of such quantitative temporal properties. Next, we extend the usual models for temporal logic by including a distance function to measure time and analyze what restrictions should be imposed on such a function. Then we introduce appropriate temporal operators to reason about such models by turning qualitative temporal operators into (quantitative) metric temporal operators and show how the usual quantitative temporal properties of real-time systems can be expressed in this metric temporal logic. After we illustrate the application of metric temporal logic to real-time systems by several examples, we end this paper with some conclusions.},
  langid = {english},
  keywords = {Distance Function,Dominant Role,Formal Specification,System Performance,Temporal Operator},
  file = {/home/y19056ba/Zotero/storage/IT3BAWGX/Koymans - 1990 - Specifying real-time properties with metric temporal logic.pdf}
}

@article{liu2010,
  title = {Modeling and {{Optimization}} of {{Adaptive Foraging}} in {{Swarm Robotic Systems}}},
  author = {Liu, Wenguo and Winfield, Alan F. T.},
  year = 2010,
  month = dec,
  journal = {The International Journal of Robotics Research},
  volume = {29},
  number = {14},
  pages = {1743--1760},
  publisher = {SAGE Publications Ltd STM},
  issn = {0278-3649},
  doi = {10.1177/0278364910375139},
  urldate = {2025-08-21},
  abstract = {Understanding the effect of individual parameters on the collective performance of swarm robotic systems in order to design and optimize individual robot behaviors is a significant challenge. In this paper we present a macroscopic probabilistic model of adaptive collective foraging in a swarm of robots, where each robot in the swarm is capable of adjusting its time threshold parameters following the rules described by Liu et al. 2007. The swarm adapts the ratio of foragers to resters (division of labor) in order to maximize the net swarm energy for a given food density. A probabilistic finite state machine (PFSM) and a number of difference equations are developed to describe collective foraging at a macroscopic level. To model adaptation we introduce the new concepts of the sub-PFSM and private/public time thresholds. The model has been validated extensively with simulation trials, and results show that the model achieves very good accuracy in predicting the group performance of the swarm. Finally, a real-coded genetic algorithm is used to explore the parameter spaces and optimize the parameters of the adaptation algorithm. Although this paper presents a macroscopic probabilistic model for adaptive foraging, we argue that the approach could be applied to any adaptive swarm system in which the heterogeneity of the system is coupled with its time parameters.},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/Z4SIEXH8/Liu and Winfield - 2010 - Modeling and Optimization of Adaptive Foraging in Swarm Robotic Systems.pdf}
}

@inproceedings{maoz2019,
  title = {Symbolic {{Repairs}} for {{GR}}(1) {{Specifications}}},
  booktitle = {{International Conference on Software Engineering}},
  author = {Maoz, Shahar and Ringert, Jan Oliver and Shalom, Rafi},
  year = 2019,
  month = may,
  pages = {1016--1026},
  issn = {1558-1225},
  doi = {10.1109/ICSE.2019.00106},
  urldate = {2025-05-23},
  abstract = {Unrealizability is a major challenge for GR(1), an expressive assume-guarantee fragment of LTL that enables efficient synthesis. Some works attempt to help engineers deal with unrealizability by generating counter-strategies or computing an unrealizable core. Other works propose to repair the unrealizable specification by suggesting repairs in the form of automatically generated assumptions. In this work we present two novel symbolic algorithms for repairing unrealizable GR(1) specifications. The first algorithm infers new assumptions based on the recently introduced JVTS. The second algorithm infers new assumptions directly from the specification. Both algorithms are sound. The first is incomplete but can be used to suggest many different repairs. The second is complete but suggests a single repair. Both are symbolic and therefore efficient. We implemented our work, validated its correctness, and evaluated it on benchmarks from the literature. The evaluation shows the strength of our algorithms, in their ability to suggest repairs and in their performance and scalability compared to previous solutions.},
  keywords = {Benchmark testing,Cascading style sheets,Glass,GR(1),Maintenance engineering,reactive synthesis,repair,Safety,Scalability,Standards},
  file = {/home/y19056ba/Zotero/storage/97Q9GCRG/Maoz et al. - 2019 - Symbolic Repairs for GR(1) Specifications.pdf}
}

@inproceedings{mavridou2020,
  title = {The {{Ten Lockheed Martin Cyber-Physical Challenges}}: {{Formalized}}, {{Analyzed}}, and {{Explained}}},
  shorttitle = {The {{Ten Lockheed Martin Cyber-Physical Challenges}}},
  booktitle = {{International Requirements Engineering Conference}},
  author = {Mavridou, Anastasia and Bourbouh, Hamza and Giannakopoulou, Dimitra and Pressburger, Thomas and Hejase, Mohammad and Garoche, Pierre-Loïc and Schumann, Johann},
  year = 2020,
  month = aug,
  pages = {300--310},
  issn = {2332-6441},
  doi = {10.1109/RE48521.2020.00040},
  urldate = {2025-11-27},
  abstract = {Capturing and analyzing requirements of Cyber-Physical Systems (CPS) can be challenging, since CPS models typically involve time-varying and real-valued variables, physical system dynamics, or even adaptive behavior. MATLAB/Simulink is a development and simulation framework that is widely used in industry to capture such systems. In this paper, we report on the application of NASA Ames tools to perform end-to-end analysis of the Ten Lockheed Martin Challenge Problems (LMCPS). LMCPS is a set of industrial Simulink model benchmarks and natural language requirements developed by domain experts. Our framework, which integrates the tools FRET and COCOSIM, is used to: 1) elicit, explain, and formalize the semantics of the given natural language requirements; 2) generate verification code and monitors that can be automatically attached to the Simulink models; 3) perform verification by using SMT-based model checkers. FRET and COCOS1M are open source, and can be used by other researchers and practitioners to replicate our case study. We provide a categorization of recurring patterns in the formalization of the requirements and discuss the strengths and weaknesses of our automated verification approach.},
  keywords = {Adaptation models,Analytical models,Natural languages,Semantics,Software packages,Switches,Tools},
  file = {/home/y19056ba/Zotero/storage/GLAMITBA/Mavridou et al. - 2020 - The Ten Lockheed Martin Cyber-Physical Challenges Formalized, Analyzed, and Explained.pdf;/home/y19056ba/Zotero/storage/TVGSTV7C/9218211.html}
}

@inproceedings{pressburger2023,
  title = {Authoring, {{Analyzing}}, and~{{Monitoring Requirements}} for~a~{{Lift-Plus-Cruise Aircraft}}},
  booktitle = {Requirements {{Engineering}}: {{Foundation}} for {{Software Quality}}},
  author = {Pressburger, Tom and Katis, Andreas and Dutle, Aaron and Mavridou, Anastasia},
  editor = {Ferrari, Alessio and Penzenstadler, Birgit},
  year = 2023,
  pages = {295--308},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-29786-1_21},
  abstract = {[Context \& Motivation] Requirements specification and analysis is widely applied to ensure the correctness of industrial systems in safety critical domains. Requirements are often initially written in natural language, which is highly ambiguous, and as a second step transformed into a language with rigorous semantics for formal analysis. [Question/problem] In this paper, we report on our experience in requirements creation and analysis, as well as run-time monitor generation using the Formal Requirement Elicitation Tool (FRET), on an industrial case study for a Lift-Plus-Cruise concept aircraft. [Principal ideas/results] We study the creation of requirements directly in the structured language of FRET without a prior definition of the same requirements in natural language. We focus on requirements describing state machines and discuss the challenges that we faced, in terms of creating requirements and generating monitors. We demonstrate how realizability, i.e., checking whether a requirements specification can be implemented, is crucial for understanding temporal interdependencies among requirements. [Contribution] Our study is the first complete attempt at using FRET to create industrial, realizable requirements and generate run-time monitors. Insight from lessons learned was materialized into new features in the FRET and JKind analysis frameworks.},
  isbn = {978-3-031-29786-1},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/N6GK82IS/Pressburger et al. - 2023 - Authoring, Analyzing, and Monitoring Requirements for a Lift-Plus-Cruise Aircraft.pdf}
}

@inproceedings{schuppan2005,
  title = {Shortest {{Counterexamples}} for {{Symbolic Model Checking}} of {{LTL}} with {{Past}}},
  booktitle = {Tools and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
  author = {Schuppan, Viktor and Biere, Armin},
  editor = {Halbwachs, Nicolas and Zuck, Lenore D.},
  year = 2005,
  pages = {493--509},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-31980-1_32},
  abstract = {Shorter counterexamples are typically easier to understand. The length of a counterexample, as reported by a model checker, depends on both the algorithm used for state space exploration and the way the property is encoded. We provide necessary and sufficient criteria for a B\"uchi automaton to accept shortest counterexamples. We prove that B\"uchi automata constructed using the approach of Clarke, Grumberg, and Hamaguchi accept shortest counterexamples of future time LTL formulae, while an automaton generated with the algorithm of Gerth et al.~(GPVW) may lead to unnecessary long counterexamples. Optimality is lost in the first case as soon as past time operators are included. Adapting a recently proposed encoding for bounded model checking of LTL with past, we construct a B\"uchi automaton that accepts shortest counterexamples for full LTL. We use our method of translating liveness into safety to find shortest counterexamples with a BDD-based symbolic model checker without modifying the model checker itself. Though our method involves a quadratic blowup of the state space, it outperforms SAT-based bounded model checking on a number of examples.},
  isbn = {978-3-540-31980-1},
  langid = {english},
  keywords = {Atomic Proposition,Kripke Structure,Linear Temporal Logic,Loop Iteration,Model Check},
  file = {/home/y19056ba/Zotero/storage/EV5W43SG/Schuppan and Biere - 2005 - Shortest Counterexamples for Symbolic Model Checking of LTL with Past.pdf}
}

@inproceedings{sheridan2025,
  title = {Sharper {{Specs}} for~{{Smarter Drones}}: {{Formalising Requirements}} with~{{FRET}}},
  shorttitle = {Sharper {{Specs}} for~{{Smarter Drones}}},
  booktitle = {Requirements {{Engineering}}: {{Foundation}} for {{Software Quality}}},
  author = {Sheridan, Ois{\'i}n and Becker, Leandro Buss and Farrell, Marie and Luckcuck, Matt and Monahan, Rosemary},
  editor = {Hess, Anne and Susi, Angelo},
  year = 2025,
  pages = {350--362},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-88531-0_25},
  abstract = {[Context and motivation] Software requirements are commonly expressed in natural-language, which must be formalised if they are to be used by formal methods such as Runtime Verification (RV), where we verify that an implementation obeys its requirements during execution. [Question/problem] This paper reports on our experience of using the Formal Requirements Elicitation Tool (FRET) to formalise requirements for an autonomous tilt-rotor drone in the ProVANT Emergentia research project. Structured, formalised requirements help to refine the meaning of, and discover ambiguities in, a requirements set, which is beneficial for safety-critical systems. FRET generates a temporal logic semantics for each requirement, providing formulas that can be used for RV. [Principal ideas/results] We describe the process of formalising the natural-language requirements using FRET. We present the progress made in each of the four versions of the requirements set as new information was elicited and incorporated. Our two concrete outputs are the formalised requirement set, which we will use in our ongoing development and verification of ProVANT; and metrics about the requirements. [Contribution] From our experience, we present guidance for requirements elicitation and formalisation with FRET. We highlight situations where it was difficult to formalise these requirements and describe potential improvements to FRET to address these difficulties.},
  isbn = {978-3-031-88531-0},
  langid = {english},
  keywords = {Experience Report,FRET,Requirements Elicitation,Software Verification,Traceability},
  file = {/home/y19056ba/Zotero/storage/R7TWGRY3/Sheridan et al. - 2025 - Sharper Specs for Smarter Drones Formalising Requirements with FRET.pdf}
}

@inproceedings{sullivan2018a,
  title = {{{AUnit}}: {{A Test Automation Tool}} for {{Alloy}}},
  shorttitle = {{{AUnit}}},
  booktitle = {2018 {{IEEE}} 11th {{International Conference}} on {{Software Testing}}, {{Verification}} and {{Validation}} ({{ICST}})},
  author = {Sullivan, Allison and Wang, Kaiyuan and Khurshid, Sarfraz},
  year = 2018,
  month = apr,
  pages = {398--403},
  publisher = {IEEE},
  address = {Vasteras},
  doi = {10.1109/ICST.2018.00047},
  urldate = {2025-11-29},
  abstract = {Software models help improve the reliability of software systems: models can convey requirements, and can analyze design and implementation properties. A key strength of Alloy, a commonly used first-order modeling language, is the Alloy Analyzer tool-set. The Analyzer allows users to execute commands over models by leveraging a fully automatic SATbased analysis engine. However, prior to the introduction of AUnit -- a testing framework for Alloy -- users had to rely on ad-hoc practices to validate their models. In this paper, we present our efforts to establish a formal testing environment in the Alloy Analyzer by creating an AUnit extension. We present additional grammar to support test case creation, as well as the details for executing test suites, calculating test suite coverage, and automatically generating test suites. The tool is available as a stand-alone executable at the following URL (https://sites.google.com/view/aunitanalyzer).},
  isbn = {978-1-5386-5012-7},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/VPTFD7CV/Sullivan et al. - 2018 - AUnit A Test Automation Tool for Alloy.pdf}
}

@inproceedings{vazquez2024,
  title = {Robotics: {{A New Mission}} for~{{FRET Requirements}}},
  shorttitle = {Robotics},
  booktitle = {{{NASA Formal Methods}}},
  author = {V{\'a}zquez, Gricel and Mavridou, Anastasia and Farrell, Marie and Pressburger, Tom and Calinescu, Radu},
  editor = {Benz, Nathaniel and Gopinath, Divya and Shi, Nija},
  year = 2024,
  pages = {359--376},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-60698-4_22},
  abstract = {Mobile robots are used to support planetary exploration and safety-critical environments such as nuclear plants. Central to the development of mobile robots is the specification of complex required behaviors known as missions. In this paper, we use NASA's Formal Requirements Elicitation Tool (FRET) to specify functional robotic mission requirements. To examine the applicability of FRET in the mobile robotics domain, we studied robotic mission patterns specified in Linear Temporal Logic (LTL). These patterns were originally derived from a large repository that included patterns from the literature and consultation with industrial experts. We extend this repository with those found during our extensive literature review. Although FRET has been successfully used in the past in case studies within the aerospace domain, mobile robot requirements present new challenges in their specification. To this end, our work provides a methodological basis for using FRET in the specification of robotic mission requirements.},
  isbn = {978-3-031-60698-4},
  langid = {english},
  file = {/home/y19056ba/Zotero/storage/CKNFGQDI/Vázquez et al. - 2024 - Robotics A New Mission for FRET Requirements.pdf}
}
