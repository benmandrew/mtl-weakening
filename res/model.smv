-- Model adapted from the Foraging Robots example in:
--   Hustadt, U., Ozaki, A., & Dixon, C. (2020).
--   Theorem Proving for Pointwise Metric Temporal Logic Over the Naturals via Translations.
--   Journal of Automated Reasoning, 64(8), 1553–1610.
--   https://doi.org/10.1007/s10817-020-09541-4

MODULE main

DEFINE
  TIME_R := 5;
  TIME_D := 5;

VAR
  state : { resting, leavingHome, randomWalk, moveToFood, scanArena, grabFood, moveToHome, deposit, homing };
  timer : 1..100;

-- Assumptions encoded in the state machine:
--   G (resting -> F[1,TIME_R] leavingHome)
--   G (leavingHome -> F[2,3] randomWalk)
--   G (randomWalk -> F[1,∞] homing | moveToFood)
--   G (moveToFood -> F[1,∞] grabFood | homing | scanArena)
--   G (scanArena -> F[1,∞] randomWalk | moveToFood | homing)
--   G (grabFood -> F[2,3] moveToHome)
--   G (moveToHome -> F[1,TIME_D] deposit)
--   G (deposit -> F[3,4] resting)
--   G (homing -> F[1,TIME_D] resting)

ASSIGN
  init(state) := resting;
  next(state) :=
    case
      state = resting & timer < TIME_R : { resting, leavingHome };
      state = resting & timer = TIME_R : leavingHome;

      state = leavingHome & timer = 2 : {leavingHome, randomWalk };
      state = leavingHome & timer = 3 : randomWalk;

      state = randomWalk : { homing, moveToFood };

      state = moveToFood : { grabFood, homing, scanArena };

      state = scanArena : { randomWalk, moveToFood, homing };

      state = grabFood & timer = 2 : {grabFood, moveToHome };
      state = grabFood & timer = 3 : moveToHome;

      state = moveToHome & timer < TIME_D : { moveToHome, deposit };
      state = moveToHome & timer = TIME_D : deposit;

      state = deposit & timer = 3 : { deposit, resting };
      state = deposit & timer = 4 : resting;

      state = homing & timer < TIME_D : { homing, resting };
      state = homing & timer = TIME_D : resting;

      TRUE : state; -- Shouldn't happen
    esac;

  init(timer) := 0;
  next(timer) :=
    case
      next(state) != state : 0;         -- reset timer on state change
      TRUE : timer + 1;                 -- otherwise increment
    esac;
