-- Model adapted from the Foraging Robots example in:
--   Hustadt, U., Ozaki, A., & Dixon, C. (2020).
--   Theorem Proving for Pointwise Metric Temporal Logic Over the Naturals via Translations.
--   Journal of Automated Reasoning, 64(8), 1553–1610.
--   https://doi.org/10.1007/s10817-020-09541-4

-- Changes from the paper:
--   Removed the scanArena state, as this allows infinite loops of searching without coming back to rest

MODULE main

DEFINE
  TIME_R := 5;
  TIME_D := 5;
  MAX_TIMER := 10;

VAR
  state : { resting, leavingHome, randomWalk, moveToFood, grabFood, moveToHome, deposit, homing };
  timer : 0..MAX_TIMER; -- Should be the maximum time that any transition can take

DEFINE
  resting_p := state = resting;
  leavingHome_p := state = leavingHome;
  randomWalk_p := state = randomWalk;
  moveToFood_p := state = moveToFood;
  grabFood_p := state = grabFood;
  moveToHome_p := state = moveToHome;
  deposit_p := state = deposit;
  homing_p := state = homing;
  searching_p := leavingHome_p | randomWalk_p | moveToFood_p;

-- Assumptions encoded in the state machine:
--   G (resting -> F[1,TIME_R] leavingHome)
--   G (leavingHome -> F[2,3] randomWalk)
--   G (randomWalk -> F[1,∞] homing | moveToFood)
--   G (moveToFood -> F[1,∞] grabFood | homing)
--   G (grabFood -> F[2,3] moveToHome)
--   G (moveToHome -> F[1,TIME_D] deposit)
--   G (deposit -> F[3,4] resting)
--   G (homing -> F[1,TIME_D] resting)

ASSIGN
  init(state) := resting;
  next(state) :=
    case
      state = resting & timer < TIME_R : { resting, leavingHome };
      state = resting & timer = TIME_R : leavingHome;

      state = leavingHome & timer = 2 : {leavingHome, randomWalk };
      state = leavingHome & timer = 3 : randomWalk;

      state = randomWalk : { homing, moveToFood };

      state = moveToFood : { grabFood, homing };

      state = grabFood & timer = 2 : {grabFood, moveToHome };
      state = grabFood & timer = 3 : moveToHome;

      state = moveToHome & timer < TIME_D : { moveToHome, deposit };
      state = moveToHome & timer = TIME_D : deposit;

      state = deposit & timer = 3 : { deposit, resting };
      state = deposit & timer = 4 : resting;

      state = homing & timer < TIME_D : { homing, resting };
      state = homing & timer = TIME_D : resting;

      TRUE : state; -- Shouldn't happen
    esac;

  init(timer) := 0;
  next(timer) :=
    case
      next(state) != state : 0;      -- Reset timer on state change
      timer < MAX_TIMER : timer + 1; -- Otherwise increment
      TRUE : timer;                  -- Saturate timer
    esac;
