MODULE main

DEFINE
  TIME_R := 5;
  TIME_D := 5;
  MAX_TIMER := 10;
  MAX_SEARCHING_TIMER := 40;

VAR
  state : { resting, leavingHome, randomWalk, moveToFood, scanArena, grabFood, moveToHome, deposit, homing };
  timer : 1..MAX_TIMER; -- Should be the maximum time that any transition can take
  searching_timer : 1..MAX_SEARCHING_TIMER;

DEFINE
  resting_p :=     state = resting;
  leavingHome_p := state = leavingHome;
  randomWalk_p :=  state = randomWalk;
  moveToFood_p :=  state = moveToFood;
  scanArena_p :=   state = scanArena;
  grabFood_p :=    state = grabFood;
  moveToHome_p :=  state = moveToHome;
  deposit_p :=     state = deposit;
  homing_p :=      state = homing;
  searching_p :=   leavingHome_p | randomWalk_p | moveToFood_p | scanArena_p;

ASSIGN
  init(state) := resting;
  next(state) :=
    case
      state = resting & timer < TIME_R : { resting, leavingHome };
      state = resting & timer = TIME_R : leavingHome;

      state = leavingHome & timer = 1 & searching_timer < MAX_SEARCHING_TIMER : {leavingHome, randomWalk };
      state = leavingHome & timer = 2 & searching_timer < MAX_SEARCHING_TIMER : randomWalk;

      state = randomWalk & searching_timer < MAX_SEARCHING_TIMER : { randomWalk, homing, moveToFood };

      state = moveToFood & searching_timer < MAX_SEARCHING_TIMER : { moveToFood, grabFood, homing, scanArena };

      state = scanArena & searching_timer < MAX_SEARCHING_TIMER : { scanArena, homing, moveToFood, randomWalk };

      searching_timer = MAX_SEARCHING_TIMER : { homing };

      state = grabFood & timer = 1 : { grabFood, moveToHome };
      state = grabFood & timer = 2 : moveToHome;

      state = moveToHome & timer < TIME_D : { moveToHome, deposit };
      state = moveToHome & timer = TIME_D : deposit;

      state = deposit & timer = 2 : { deposit, resting };
      state = deposit & timer = 3 : resting;

      state = homing & timer < TIME_D : { homing, resting };
      state = homing & timer = TIME_D : resting;

      TRUE : state;
    esac;

  init(timer) := 1;
  next(timer) :=
    case
      next(state) != state : 1;      -- Reset timer on state change
      timer < MAX_TIMER : timer + 1; -- Otherwise increment
      TRUE : timer;                  -- Saturate timer
    esac;

  init(searching_timer) := 1;
  next(searching_timer) :=
    case
      next(searching_p) != searching_p : 1;      -- Reset timer if we start searching
      searching_p & searching_timer < MAX_SEARCHING_TIMER : searching_timer + 1; -- Otherwise increment if we're searching
      TRUE : searching_timer;                  -- Saturate timer
    esac;
