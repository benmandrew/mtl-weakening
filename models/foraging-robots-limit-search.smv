MODULE main

DEFINE
  TIME_R := 5;
  TIME_D := 5;
  MAX_TIMER := 10;
  BATTERY_FULL_VALUE := 20;
  BATTERY_ABORT_VALUE := 10;

VAR
  state : { resting, leavingHome, randomWalk, moveToFood, scanArena, grabFood, moveToHome, deposit, homing, no_battery };
  timer : 1..MAX_TIMER; -- Should be the maximum time that any transition can take
  battery_value : 0..BATTERY_FULL_VALUE;

DEFINE
  resting_p :=     state = resting;
  leavingHome_p := state = leavingHome;
  randomWalk_p :=  state = randomWalk;
  moveToFood_p :=  state = moveToFood;
  scanArena_p :=   state = scanArena;
  grabFood_p :=    state = grabFood;
  moveToHome_p :=  state = moveToHome;
  deposit_p :=     state = deposit;
  homing_p :=      state = homing;
  searching_p :=   leavingHome_p | randomWalk_p | moveToFood_p | scanArena_p;
  no_battery_p :=  state = no_battery;

ASSIGN
  init(state) := resting;
  next(state) :=
    case
      battery_value <= 0 : no_battery;

      state = resting & timer < TIME_R : { resting, leavingHome };
      state = resting & timer = TIME_R : leavingHome;

      state = leavingHome & timer = 1 & battery_value > BATTERY_ABORT_VALUE : {leavingHome, randomWalk };
      state = leavingHome & timer = 2 & battery_value > BATTERY_ABORT_VALUE : randomWalk;

      state = randomWalk & battery_value > BATTERY_ABORT_VALUE : { randomWalk, homing, moveToFood };

      state = moveToFood & battery_value > BATTERY_ABORT_VALUE : { moveToFood, grabFood, homing, scanArena };

      state = scanArena & battery_value > BATTERY_ABORT_VALUE : { scanArena, homing, moveToFood, randomWalk };

      searching_p & battery_value <= BATTERY_ABORT_VALUE : { homing };

      state = grabFood & timer = 1 : { grabFood, moveToHome };
      state = grabFood & timer = 2 : moveToHome;

      state = moveToHome & timer < TIME_D : { moveToHome, deposit };
      state = moveToHome & timer = TIME_D : deposit;

      state = deposit & timer = 2 : { deposit, resting };
      state = deposit & timer = 3 : resting;

      state = homing & timer < TIME_D : { homing, resting };
      state = homing & timer = TIME_D : resting;

      TRUE : state;
    esac;

  init(timer) := 1;
  next(timer) :=
    case
      next(state) != state : 1;      -- Reset timer on state change
      state != no_battery & timer < MAX_TIMER : timer + 1; -- Otherwise increment
      TRUE : timer;                  -- Saturate timer
    esac;

  init(battery_value) := BATTERY_FULL_VALUE;
  next(battery_value) :=
    case
      next(state) = resting : BATTERY_FULL_VALUE; -- Recharge when resting
      battery_value > 0 : battery_value - 1; -- Decrease battery otherwise
      TRUE : 0;
    esac;
